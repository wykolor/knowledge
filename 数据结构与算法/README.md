- 什么是数据结构？

存储和计算是程序的两大基础功能，数据结构是专门研究数据存储的学科。
很多时候，我们无法使用简单的数字、字符串、布尔就能完整的描述数据，
可能我们希望使用数组、对象、或者他们组合而成的符合结构对数据进行描述，
这种复合的结构就是数据结构。常见的数据结构有：**数组**、**链表**、**树**、**图**等

- 什么是算法？

存储和计算是程序的两大基础功能，算法是专门研究运算过程的学科。
一个程序，很多时候都需要根据一种已知数据，通过计算，得到另一个未知数据，
这个运算过程使用的方法，就是算法
常见的算法有：**穷举法**、**分治法**、**贪心算法**、**动态规划**等

- 数据结构和算法有什么关系？

一个面向的是存储，一个面向的是运算，他们共同构成了计算机程序的两个重要部分。
有了相应的数据结构，免不了对这种数据结构的各种变化进行计算，所以，很多时候，
某种数据机构都会自然而然的搭配不少的算法。

# 线性结构

线性结构是数据结构中的一种分类，用于表示一系列的元素形成的有序集合
常见的线性结构有**数组**、**链表**、**栈**、**队列**

## 数组

**数组是一整块连续的内存空间，它是由固定数量的元素组成，具有以下特征：**

1. 整个数组占用的内存空间是连续的
2. 数组中元素的数量是固定的（不可增加也不可减少），创建数组时就必须指定其长度
3. 每个元素占用的内存大小完全是一样的

所以在创建数组时，需要指定两个地方：

1. 数组的长度
2. 数组每个项占用的内存大小

根据数组的基本特征，可以推导出数据具有以下特点

1. 通过下标寻找元素的效率极高，因此遍历速度快
2. 无法添加和删除数据，虽然可以通过某种算法完成类似操作，但会增加额外的内存开销或者时间开销
3. 如果数组需要的空间很大，可能一时无法找到足够大的连续内存


## 链表

为弥补数组的缺陷而出现的一种数据结构，它具有以下基本特征：

1. 每个元素除了存储数据，需要有额外的内存存储一个引用（地址），来指向下一个元素
2. 每个元素占用的内存空间并不要求是连续的
3. 往往使用链表的第一个节点（根节点）来代表整个链表

> 在链表中，每个节点都可以作为根节点

根据链表的基本特征，可以推导出它具有以下特点：

1. 长度是可变的，随时可以增加和删除元素
2. 插入和删除元素的效率极高
3. 由于要存储下一个元素的地址，会增加额外的内存开销
4. 通过下标查询链表中的某个节点，效率很低，因此链表的下标遍历效率低


# 排序算法

> 排序算法没有优劣之分，在不同的场景中，不同的排序算法执行效率不同

- 原地排序： 不开辟新的内存空间存放数组中的数据（不新建数组）
- 非原地排序：要开辟新的内存空间存放数组中的数据(会新建数组)

1. **选择排序 Selection Sort**

一次选择排序，可以将某个小区的最小值排列到该区域的第一位，具体的方式是：

1. 找出该区域的最小值
2. 将该值与该区域的第一个值交换
3. 对下一个区域重复上述过程，直到排序完成

2. **冒泡排序 Bubble Sort**

一次冒泡排序，可以将某个区域序列的最大值排序到该区域的最后一位，具体方式如下：

1. 将第1位和第2位比较，如果前者比后者大则交换
2. 将第2位和第3位比较，如果前者比后者大则交换
3. 依次类推，直到比较到该区域的最后两位
4. 重复上述过程，直到排序完成

3. **插入排序 Insertion Sort**

将序列分为两个部分，一部分是有序的，一部分是无序的，现在要做的是，
就是不断的从无序的部分取出数据，加入到有序的部分，直到整个排序完成

例如： 序列 [5, 7, 2, 3, 6]

1. 分为有序的序列和无序的序列 (5) (7 2 3 6)
2. 不断的扩充有序序列 (5 7) (2 3 6)
3. 不断的扩充有序序列 (2 5 7) (3 6)
4. 不断的扩充有序序列 (2 3 5 7) (6)
5. 不断扩充有序序列 (2 3 5 6 7)
6. 排序完成

4. **快速排序 Quick Sort**

选择一个数（比如序列的最后一位）作为基准数，将整个序列排成两部分，一部分比该数小，另一部分比该数大，基准数在中间，然后对剩余的序列做同样的事情，直到排序完成

例如：序列 [5, 7, 2, 3, 6, 4]

1. 选择4作为基准数，排序成为：(3 2) 4 (7 6 5)
2. 对于3，2，继续使用该方式排序， 得到 (2 3) 4 (7 6 5)
3. 对于7,6,5，继续使用该方式排序，得到：(2 3) 4 (5 6 7)
4. 排序完成

# 查询算法

1. **顺序查找 Inorder Search**

即普通的遍历，属于算法的穷举法

2. **二分查找 Binary Search**

如果一个序列是一个排序好的序列，则使用二分查找可以极大的缩短查找时间
具体的做法是：
查找该序列中中间未知的数据

1. 相等，找到
2. 要找的数据较大，则对后续部分的数据做同样的步骤
3. 要找的数据较小，则对前面部分的数据做同样的步骤

3. **插值查找 Interpolation Search**

插值查找是对二分查找的进一步改进
如果序列不仅是一个排序好的序列，而且序列的步长大致相同，则使用插值查找

插值查找基于如下假设：下标之间的距离比和数据之间的距离比大致相同，即：

(目标下标 - 最小下标) / (最大下标 - 最小下标) ≈ (目标值 - 最小值) / (最大值 - 最小值)

因此可以计算出大致的下标落点：

目标下标 ≈ (目标值 - 最小值) / (最大值 - 最小值) * (最大下标 - 最小下标) + 最小下标

这样就可以计算出大致的下标落点，后续的比较和二分查找一样


# 树

树是一个类似于链表的二维结构，每个节点可以指向0个或多个其他节点

树具有以下特点：
1. 单根：如果一个节点A指向了另一个节点B，仅能通过A直接找到B节点，不可能通过其他节点找到B节点
2. 无环：节点的指向不能形成环

树的术语：
1. 节点的度：某个节点的度 = 该节点子节点的数量
2. 树的度：一棵树中，最大的节点的度为该树的度
3. 节点的层：从艮开始定义起，根为第一层，根的子节点为第二层，以此类推
4. 树的高度或深度：树中节点的最大层次
5. 叶子节点：度为0的节点成为叶节点
6. 分支节点：非叶子节点
7. 子节点、父节点：相对概念，如果A节点有一个子节点B，则A是B的父节点，B是A的子节点
8. 兄弟节点：如果两个节点有同一个父节点，则他们互为兄弟节点
9. 祖先节点：某个节点的祖先节点，是从树的根到该节点本身经过的所有节点
10. 后代节点：如果A是B的祖先节点，B则是A的后代节点
11. 根节点：树的最顶端的节点是根节点
12. 子树： 

树的代码表示法：

```javascript
    function Node(value) {
        this.value = value;
        this.children = [];
    }
```

## 二叉树

一棵树的度为2，则该树是二叉树

二叉树可以用下面的代码表示

```javascript
    function Node(value) {
        this.value = value;
        this.left  = null;
        this.right = null;
    }
```

## 二叉树的相关算法

**eg: 有如下一棵二叉树**

![二叉树](https://github.com/wykolor/knowledge/raw/master/images/tree.png)

用代码构建一颗上图的二叉树

```javascript
    /**
     *
     * 构建一个二叉树节点
     * @param {*} value
     */
    function Node(value) {
        this.value = value;
        this.left = null;
        this.right = null;
    }

    var a = new Node('a');
    var b = new Node('b');
    var c = new Node('c');
    var d = new Node('d');
    var e = new Node('e');
    var f = new Node('f');

    a.left = b;
    a.right = e;
    b.left = c;
    b.right = d;
    e.left = f;
```

1. 对二叉树遍历打印
    1. 前序遍历 DLR (先自己，再左边，后右边)

    ```javascript
        /**
         *前序遍历
        *
        * @param {*} root
        */
        function DLR(root) {
            if (!root) return;
            console.log(root.value);
            DLR(root.left);
            DLR(root.right);
        }
    ```

    2. 中序遍历 LDR (先左边，再自己，后右边)

    ```javascript
        /**
         *中序遍历
        *
        * @param {*} root
        */
        function LDR(root) {
            if (!root) return;
            LDR(root.left);
            console.log(root.value);
            LDR(root.right);
        }
    ```

    3. 后序遍历 LRD (先左边，再右边，后自己)

    ```javascript
        /**
         *后序遍历
        *
        * @param {*} root
        */
        function LRD(root) {
            if (!root) return;
            LRD(root.left);
            LRD(root.right);
            console.log(root.value);
        }

    ```

2. 根据前序遍历和中序遍历的结果，得到一颗二叉树

```javascript
    /**
     * 根据前序遍历和中序遍历的结果，得到一颗二叉树
     * 
     * 步骤： 
     * 首先进行错误预估 (如果前序和中序长度不等或者某个序列长度为0)
     * 1. 找出根的值，构建根节点
     * 2. 找出根节点在中序遍历中的索引值
     * 3. 找出左节点的前序遍历和中序遍历 递归getTree
     * 4. 找出右节点的前序遍历和中序遍历 递归getTree
     * 5. 最终根节点的left等于步骤3的结果
     * 6. 最终根节点的right等于步骤4的结果
     *
     * @param {*} dlr 前序遍历
     * @param {*} ldr 中序遍历
     */
    function getTree(dlr, ldr) {

        dlr = dlr.split("");
        ldr = ldr.split("");
        if (dlr.length !== ldr.length) throw new Error('无效的数据');
        if (dlr.length === 0) return null;

        var rootValue = dlr[0]; // 找出根节点的值
        var root = new Node(rootValue); // 构建根节点

        var rootIndex = ldr.indexOf(rootValue); // 找出根节点在中序遍历中的索引
        // 分割出左节点的前序遍历和中序遍历
        var leftLdr = ldr.slice(0, rootIndex).join(""); // 左边节点的中序遍历
        var leftDlr = dlr.slice(1, leftLdr.length + 1).join(""); // 左节点的前序遍历
        root.left = getTree(leftDlr, leftLdr);
    
        var rightLdr = ldr.slice(rootIndex + 1).join(""); // 右节点的中序遍历
        var rightDlr = dlr.slice(leftLdr.length + 1).join(""); // 右节点的前序遍历
        root.right = getTree(rightDlr, rightLdr);

        return root; // 返回根节点
    }
```

3. 计算树的深度

```javascript
    /**
     * 得到一棵树的深度
     * 思路：
     * 一棵树的深度等于左右节点的深度最大值加1
     * @param {*} root
     */
    function getDeep(root) {
        if(!root) return 0;
        return Math.max(getDeep(root.left), getDeep(root.right)) + 1;
    }
    console.log(getDeep(a)); // 3
```

4. 查询二叉树
    1. 深度优先
    2. 广度优先
5. 比较两颗二叉树，得到比较的结果
6. 将一个数组，转换为排序二叉树
7. 在一个排序二叉树中查找目标